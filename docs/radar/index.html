<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>駅メモ！レーダー検知範囲</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    /*（CSS はあなたの最新版からそのまま）*/
    :root {
      color-scheme: light;
      --accent: #2f80ff;
      --accent-soft: #e3f0ff;
      --accent-strong: #175ddc;
      --border-soft: #dde2eb;
      --text-main: #222;
      --text-sub: #666;
      --bg: #f5f6f8;
      --control-radius: 10px;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0; padding: 0; height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg); color: var(--text-main);
    }

    body { display: flex; flex-direction: column; }
    #app { flex: 1 1 auto; display: flex; flex-direction: column; min-height: 0; }

    #controls {
      flex: 0 0 auto; background: #fff;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
      padding: env(safe-area-inset-top) 8px 6px;
      position: sticky; top: 0; z-index: 1000;
    }

    #controls-inner {
      max-width: 720px; margin: 0 auto; padding: 4px 8px;
    }

    #controls-title {
      font-size: 13px; font-weight: 600;
      margin: 0 0 4px; color: var(--text-sub);
    }

    .form-grid {
      display: grid; grid-template-columns: 1fr; grid-row-gap: 6px;
    }

    .form-row { display: flex; align-items: center; gap: 6px; }
    .form-label {
      flex: 0 0 auto; font-size: 12px; color: var(--text-sub); white-space: nowrap;
    }
    .form-control-wrap { flex: 1 1 auto; min-width: 0; }

    input[type="text"], input[type="number"], select {
      width: 100%; font-size: 14px;
      padding: 6px 10px; border-radius: var(--control-radius);
      border: 1px solid var(--border-soft); background: #fff;
      transition: border-color .15s, box-shadow .15s;
    }
    input:focus, select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(47,128,255,0.18);
    }

    #drawButton {
      width: 110px; padding: 8px 0;
      border-radius: 999px; border: none;
      font-size: 14px; font-weight: 600;
      color: #fff;
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      box-shadow: 0 3px 8px rgba(23,93,220,0.4);
      cursor: pointer;
    }

    #selectedStationLabel {
      margin-top: 4px; font-size: 12px; color: var(--text-sub);
    }

    @media (min-width:640px){
      .form-grid {
        grid-template-columns: minmax(0,2fr) auto auto auto;
        grid-column-gap: 8px; align-items: flex-end;
      }
      #drawButton { width: 100%; }
    }

    #map { flex: 1 1 auto; min-height: 200px; width: 100%; }
    .leaflet-control-attribution { font-size: 10px; }
  </style>
</head>
<body>
  <div id="app">
    <div id="controls">
      <div id="controls-inner">
        <p id="controls-title">指定した駅がレーダーで取得可能な範囲を描画します</p>

        <div class="form-grid">
          <div class="form-row">
            <div class="form-label">駅名検索</div>
            <div class="form-control-wrap">
              <input id="searchInput" type="text" placeholder="例: 三崎口, 東京, 新大阪..." autocomplete="off" />
            </div>
          </div>

          <div class="form-row">
            <div class="form-label">候補</div>
            <div class="form-control-wrap">
              <select id="stationSelect"></select>
            </div>
          </div>

          <div class="form-row">
            <div class="form-label">検知数</div>
            <div class="form-control-wrap">
              <input id="nInput" type="number" min="1" max="40" value="18" />
            </div>
          </div>

          <div class="form-row">
            <div class="form-label">グリッド(px)</div>
            <div class="form-control-wrap">
              <input id="gridInput" type="number" min="2" max="40" value="12" />
            </div>
          </div>

          <div class="form-row" style="grid-column:1/-1; margin-top:4px;">
            <div class="form-control-wrap" style="max-width:140px;">
              <button id="drawButton">描画</button>
            </div>
          </div>
        </div>

        <div id="selectedStationLabel">選択中の駅: なし</div>
      </div>
    </div>

    <div id="map"></div>
  </div>

  <script>
    /* ---- データ・変数 ---- */
    let stations = [];
    let stationPositions = [];
    const idToIndex = new Map();

    let map;
    let overlayLayer;
    let stationMarker;

    let currentStationIndex = null;

    /* 中心に移動して再描画 */
    let unifiedDelayTimer = null;
    function scheduleCenterOnStationAndRedraw() {
      if (unifiedDelayTimer) clearTimeout(unifiedDelayTimer);
      unifiedDelayTimer = setTimeout(() => {
        const st = getSelectedStation();
        if (!st) return;

        const latlng = [st.lat, st.lng];
        const targetZoom = Math.max(map.getZoom(), 13);
        map.setView(latlng, targetZoom);

        updateStationMarker();
        drawOverlay();
      }, 500);
    }

    let redrawOnlyTimer = null;
    function scheduleRedrawOnly() {
      if (redrawOnlyTimer) clearTimeout(redrawOnlyTimer);
      redrawOnlyTimer = setTimeout(() => {
        drawOverlay();     // ★ 駅の再センタリングはしない
      },1000);
    }


    /* ---- DOM ---- */
    const searchInput = document.getElementById("searchInput");
    const stationSelect = document.getElementById("stationSelect");
    const nInput = document.getElementById("nInput");
    const gridInput = document.getElementById("gridInput");
    const drawButton = document.getElementById("drawButton");
    const selectedStationLabel = document.getElementById("selectedStationLabel");

    /* ---- 初期化 ---- */
    initMap();
    loadStations();

    function initMap() {
      map = L.map("map", {
        center: [35.681236, 139.767125],
        zoom: 11,
      });

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors /  駅情報は <a href="https://github.com/Seo-4d696b75/station_database/blob/main/README.md">駅データ</a> を利用しています',
      }).addTo(map);

      map.createPane("gridPane");
      map.getPane("gridPane").style.zIndex = 400;
      map.getPane("gridPane").style.pointerEvents = "none";

      map.createPane("stationPane");
      map.getPane("stationPane").style.zIndex = 650;

      overlayLayer = L.layerGroup().addTo(map);

      map.on("moveend zoomend", () => {
        if (currentStationIndex == null) return;
        scheduleRedrawOnly();
      });
    }

    async function loadStations() {
      const resp = await fetch("station.json");
      const data = await resp.json();

      stations = data.map((s, index) => ({
        id: s.id,
        name: s.name,
        name_kana: s.name_kana || "",
        lat: Number(s.lat),
        lng: Number(s.lng),
        index,
      }));

      stationPositions = stations.map(s => ({
        id: s.id, name: s.name, name_kana: s.name_kana,
        lat: s.lat, lng: s.lng, index: s.index
      }));

      stations.forEach((s, i) => idToIndex.set(s.id, i));

      updateStationCandidates("");
      setupEventHandlers();
    }

    function setupEventHandlers() {
      /* 駅名検索 → 候補更新（即時）＋スクロール&描画は1秒後 */
      searchInput.addEventListener("input", () => {
        updateStationCandidates(searchInput.value);
        scheduleCenterOnStationAndRedraw();
      });

      stationSelect.addEventListener("change", () => {
        const st = getSelectedStation();
        if (!st) return;
        currentStationIndex = st.index;
        updateSelectedStationLabel();
        scheduleCenterOnStationAndRedraw();
      });

      drawButton.addEventListener("click", () => {
        scheduleCenterOnStationAndRedraw();  // 即描画でもOK
      });

      /* nInput / gridInput → 1秒停止したら描画 */
      nInput.addEventListener("input", scheduleRedrawOnly);
      gridInput.addEventListener("input", scheduleRedrawOnly);
    }

    /* ---- インクリメンタルサーチ（完全一致優先） ---- */
    function updateStationCandidates(query) {
      const q = (query || "").trim().toLowerCase();
      let list = [];

      if (q.length >= 1) {
        const exact = stationPositions.find(
          s => s.name.toLowerCase() === q || (s.name_kana || "").toLowerCase() === q
        );

        if (exact) {
          const others = stationPositions.filter(
            s =>
              s.id !== exact.id &&
              (s.name.toLowerCase().includes(q) ||
               (s.name_kana || "").toLowerCase().includes(q))
          );

          list = [exact, ...others.slice(0, 199)];
        } else {
          list = stationPositions.filter(
            s =>
              s.name.toLowerCase().includes(q) ||
              (s.name_kana || "").toLowerCase().includes(q)
          ).slice(0, 200);
        }
      } else {
        list = stationPositions.slice(0, 100);
      }

      stationSelect.innerHTML = "";
      const frag = document.createDocumentFragment();
      list.forEach(s => {
        const o = document.createElement("option");
        o.value = s.id;
        o.textContent = s.name;
        frag.appendChild(o);
      });
      stationSelect.appendChild(frag);

      if (list.length > 0) {
        stationSelect.value = list[0].id;
        currentStationIndex = idToIndex.get(list[0].id);
        updateSelectedStationLabel();
      } else {
        currentStationIndex = null;
        updateSelectedStationLabel();
      }
    }

    /* ---- 選択駅 ---- */
    function getSelectedStation() {
      const id = Number(stationSelect.value);
      if (!idToIndex.has(id)) return null;
      return stationPositions[idToIndex.get(id)];
    }

    function updateSelectedStationLabel() {
      const st = getSelectedStation();
      selectedStationLabel.textContent = st ? `選択中の駅: ${st.name}` : "選択中の駅: なし";
    }

    /* ---- マーカー更新 ---- */
    function updateStationMarker() {
      const st = getSelectedStation();
      if (!st) return;

      const latlng = [st.lat, st.lng];
      if (stationMarker) {
        stationMarker.setLatLng(latlng);
      } else {
        stationMarker = L.circleMarker(latlng, {
          radius: 10,
          color: "#ff0000",
          weight: 3,
          fillColor: "#ff4d4d",
          fillOpacity: 0.9,
          pane: "stationPane",
        }).addTo(map);
      }
    }

    /* ---- グリッド描画 ---- */
    function drawOverlay() {
      const st = getSelectedStation();
      if (!st) return;

      const n = Math.max(1, Number(nInput.value) || 1);
      const gridPx = Math.max(2, Number(gridInput.value) || 8);

      overlayLayer.clearLayers();

      const targetLat = st.lat;
      const targetLng = st.lng;

      const mapSize = map.getSize();
      for (let y = 0; y < mapSize.y; y += gridPx) {
        for (let x = 0; x < mapSize.x; x += gridPx) {
          const latlng = map.containerPointToLatLng([x + gridPx/2, y + gridPx/2]);
          const dxT = latlng.lng - targetLng;
          const dyT = latlng.lat - targetLat;
          const dTarget2 = dxT*dxT + dyT*dyT;

          if (dTarget2 === 0) {
            addRect(x, y, gridPx, "hit");
            continue;
          }

          let cnt = 0;
          for (let i = 0; i < stationPositions.length; i++) {
            if (i === st.index) continue;
            const sp = stationPositions[i];
            const dx = latlng.lng - sp.lng;
            const dy = latlng.lat - sp.lat;
            if (dx*dx + dy*dy < dTarget2) {
              cnt++;
              if (cnt >= n) break;
            }
          }

          if (cnt < n) {
            addRect(x, y, gridPx, cnt + 1 === n ? "exact" : "inner");
          }
        }
      }
    }

    function addRect(x, y, size, type) {
      const nw = map.containerPointToLatLng([x, y]);
      const se = map.containerPointToLatLng([x+size, y+size]);

      const style =
        type === "exact" || type === "hit"
          ? { pane:"gridPane", fillColor:"#ff6666", fillOpacity:0.35, color:"#ff0000", weight:0 }
          : { pane:"gridPane", fillColor:"#6666ff", fillOpacity:0.25, color:"#0000ff", weight:0 };

      overlayLayer.addLayer(L.rectangle([nw, se], style));
    }
  </script>
</body>
</html>
