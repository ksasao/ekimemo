<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>駅メモ！レーダー検知範囲</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    :root {
      color-scheme: light;
      --accent: #2f80ff;
      --accent-soft: #e3f0ff;
      --accent-strong: #175ddc;
      --border-soft: #dde2eb;
      --text-main: #222;
      --text-sub: #666;
      --bg: #f5f6f8;
      --control-radius: 10px;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text-main);
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #app {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    /* --- コントロールエリア --- */

    #controls {
      flex: 0 0 auto;
      background: #fff;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
      padding: env(safe-area-inset-top) 6px 4px;
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    #controls-inner {
      max-width: 720px;
      margin: 0 auto;
      padding: 4px 8px;
    }

    #controls-title {
      font-size: 13px;
      font-weight: 600;
      margin: 0 0 4px;
      color: var(--text-sub);
    }

    .form-grid {
      display: grid;
      grid-template-columns: 1fr;
      grid-row-gap: 6px;
    }

    .form-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .form-label {
      flex: 0 0 auto;
      font-size: 12px;
      color: var(--text-sub);
      white-space: nowrap;
    }

    .form-control-wrap {
      flex: 1 1 auto;
      min-width: 0;
    }

    input[type="text"],
    input[type="number"],
    select {
      width: 100%;
      font-size: 14px;
      padding: 6px 10px;
      border-radius: var(--control-radius);
      border: 1px solid var(--border-soft);
      background: #fff;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      transition: border-color 0.15s, box-shadow 0.15s, background-color 0.15s;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(47, 128, 255, 0.18);
    }

    #drawButton {
      width: 110px;
      padding: 8px 0;
      border-radius: 999px;
      border: none;
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-strong) 100%);
      box-shadow: 0 3px 8px rgba(23, 93, 220, 0.4);
      cursor: pointer;
      outline: none;
      transition: transform 0.1s ease, box-shadow 0.1s ease, opacity 0.15s ease;
    }

    #drawButton:active {
      transform: translateY(1px);
      box-shadow: 0 1px 4px rgba(23, 93, 220, 0.35);
    }

    #drawButton:disabled {
      opacity: 0.6;
      box-shadow: none;
      cursor: default;
    }

    #selectedStationLabel {
      margin-top: 4px;
      font-size: 12px;
      color: var(--text-sub);
    }

    /* iOS Safari のフォーム自動ズーム対策 */
    input[type="text"],
    input[type="number"],
    select {
      font-size: 16px;  /* ここが重要。16px 以上にする */
    }

    /* PC では2〜3列レイアウトにしてコンパクトに */
    @media (min-width: 640px) {
      .form-grid {
        grid-template-columns: minmax(0, 2.2fr) minmax(0, 1.4fr) auto auto auto;
        grid-column-gap: 8px;
        align-items: flex-end;
      }

      #drawButton {
        width: 100%;
      }
    }

    /* --- マップ --- */

    #map {
      flex: 1 1 auto;
      min-height: 240px;
      width: 100%;
    }

    .leaflet-control-attribution {
      font-size: 10px;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="controls">
      <div id="controls-inner">
        <p id="controls-title">指定した駅がレーダーで取得可能な範囲を描画します</p>

        <div class="form-grid">
          <!-- 駅名検索 -->
          <div class="form-row">
            <div class="form-label">駅名検索</div>
            <div class="form-control-wrap">
              <input
                id="searchInput"
                type="text"
                placeholder="例: 三崎口, 東京, 新大阪..."
                autocomplete="off"
              />
            </div>
          </div>

          <!-- 候補 -->
          <div class="form-row">
            <div class="form-label">候補</div>
            <div class="form-control-wrap">
              <select id="stationSelect"></select>
            </div>
          </div>

          <!-- n -->
          <div class="form-row">
            <div class="form-label">検知数</div>
            <div class="form-control-wrap">
              <select id="nInput"></select>
            </div>
          </div>

          <!-- 描画ボタン -->
          <div class="form-row" style="grid-column: 1 / -1; justify-content: flex-start; margin-top: 4px;">
            <div class="form-control-wrap" style="max-width: 140px;">
              <button id="drawButton">描画</button>
            </div>
          </div>
        </div>

        <div id="selectedStationLabel">選択中の駅: なし</div>
      </div>
    </div>

    <div id="map"></div>
  </div>

  <script>
    // --- データ保持 ---
    let stations = [];
    let stationPositions = [];
    const idToIndex = new Map();

    // kd-tree 用
    let kdRoot = null;

    // Leaflet 関連
    let map;
    let overlayLayer;
    let newOverlayLayer = null; // 描画中の新しいレイヤー
    let stationMarker;

    // 現在選択中の駅インデックス
    let currentStationIndex = null;

    // 各種デバウンス用タイマー
    let searchPanTimer = null;      // 検索入力 → 駅へパン
    let mapRedrawTimer = null;      // マップ移動終了 → オーバーレイ再描画
    let paramRedrawTimer = null;    // n / グリッド変更 → オーバーレイ再描画

    // グリッド段階描画制御
    let isUserInteracting = false;  // ユーザー操作中フラグ
    let progressiveDrawTimer = null; // 段階描画用タイマー
    let currentDrawingGridSize = null; // 現在描画中のグリッドサイズ
    let currentDrawingCancelled = false; // 現在の描画がキャンセルされたか

    // DOM キャッシュ
    const searchInput = document.getElementById("searchInput");
    const stationSelect = document.getElementById("stationSelect");
    const nInput = document.getElementById("nInput");
    const drawButton = document.getElementById("drawButton");
    const selectedStationLabel = document.getElementById("selectedStationLabel");

    function fillSelectRange(selectEl, start, end, step, defaultValue, labelSuffix = '') {
      for (let v = start; v <= end; v += step) {
        const opt = document.createElement('option');
        opt.value = String(v);
        opt.textContent = labelSuffix ? `${v} ${labelSuffix}` : String(v);
        if (v === defaultValue) {
          opt.selected = true;
        }
        selectEl.appendChild(opt);
      }
    }

    // 検知数: 1〜50, 1刻み
    fillSelectRange(nInput, 1, 50, 1, 18, '駅');

    // --- 初期化 ---
    initMap();
    loadStations();

    function initMap() {
      map = L.map("map", {
        center: [35.681236, 139.767125], // 東京駅あたり
        zoom: 11,
        zoomControl: true,
        preferCanvas: true,
      });

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution:
          '&copy; OpenStreetMap contributors / 駅情報は <a href="https://github.com/Seo-4d696b75/station_database/blob/main/README.md" target="_blank" rel="noopener noreferrer">駅データ</a> を利用しています',
      }).addTo(map);

      // グリッド描画用の pane / layer
      map.createPane("gridPane");
      map.getPane("gridPane").style.zIndex = 400;
      map.getPane("gridPane").style.pointerEvents = "none";

      // 駅マーカー用 pane（最前面）
      map.createPane("stationPane");
      map.getPane("stationPane").style.zIndex = 650;

      overlayLayer = L.layerGroup().addTo(map);

      // マップ操作開始 → ユーザー操作フラグON、段階描画キャンセル、検索パンタイマーもキャンセル
      map.on("movestart zoomstart", () => {
        isUserInteracting = true;
        cancelProgressiveDraw();
        if (searchPanTimer) {
          clearTimeout(searchPanTimer);
          searchPanTimer = null;
        }
      });

      // マップ操作終了 → ユーザー操作フラグOFF、オーバーレイ再描画（パン位置は維持）
      map.on("moveend zoomend", () => {
        isUserInteracting = false;
        if (currentStationIndex == null) return;
        scheduleMapRedraw();
      });
    }

    function selectInitialStationByName(name) {
      // 名前で駅を検索
      const st = stationPositions.find(s => s.name === name);
      if (!st) return;

      // 検索ボックスは空白のまま
      searchInput.value = "";

      // 初期化時は stationSelect を直接設定
      stationSelect.innerHTML = "";
      const opt = document.createElement("option");
      opt.value = st.id;
      opt.textContent = st.name;
      stationSelect.appendChild(opt);

      // 選択インデックスをセット
      stationSelect.value = st.id;
      currentStationIndex = st.index;
      updateSelectedStationLabel();

      // 地図パンとマーカー設置
      panToSelectedStation(true);

      // グリッド描画
      drawOverlay();
    }


    async function loadStations() {
      try {
        const resp = await fetch("station.json");
        const data = await resp.json();

        stations = data.map((s, index) => ({
          id: s.id,
          code: s.code,
          name: s.name,
          name_kana: (s.name_kana || "").toString(),
          lat: Number(s.lat),
          lng: Number(s.lng),
          index,
        }));

        stationPositions = stations.map((s) => ({
          lat: s.lat,
          lng: s.lng,
          name: s.name,
          searchKey: s.name.replace(/\(.*?\)/g, '').trim(),
          name_kana: s.name_kana,
          id: s.id,
          index: s.index,
        }));

        stations.forEach((s, idx) => {
          idToIndex.set(s.id, idx);
        });

        // kd-tree 構築
        kdRoot = buildKDTree(stationPositions);

        // イベント登録
        setupEventHandlers();
        selectInitialStationByName("品川");
      } catch (e) {
        console.error("station.json の読み込みに失敗しました", e);
        alert("station.json の読み込みに失敗しました。ファイルの配置を確認してください。");
      }
    }

    let lastSearchValue = '';
    let incrementalSearchTimerId = null;

    function setupEventHandlers() {
      // インクリメンタルサーチ:
      //  - 候補の更新は即時
      //  - 入力が 1 秒止まったら現在の候補で駅にパン（但しユーザーパン中はキャンセル）
      searchInput.addEventListener("input", () => {
        const q = searchInput.value.trim();
        if (incrementalSearchTimerId !== null) {
          clearTimeout(incrementalSearchTimerId);
          incrementalSearchTimerId = null;
        }

        if (q === '') {
          lastSearchValue = '';
          if (searchPanTimer) {
            clearTimeout(searchPanTimer);
            searchPanTimer = null;
          }
          return;
        }
        // 「削除操作っぽいか？」を判定（長さが短くなっていれば削除とみなす）
        const isDeletion = q.length < lastSearchValue.length;
        lastSearchValue = q;

        if (isDeletion) {
          // バックスペース等のときは少し待ってから検索
          incrementalSearchTimerId = setTimeout(() => {
            updateStationCandidates(q);
            incrementalSearchTimerId = null;
          }, 350); // ここで待ち時間を調整
        } else {
          // 追加入力などは即時に検索
          updateStationCandidates(q);
        }

        if (searchPanTimer) clearTimeout(searchPanTimer);
        searchPanTimer = setTimeout(() => {
          panToSelectedStation(true);
        }, 1000);
      });

      // 候補選択が変わったら即座に駅＆ラベル更新（パンは行うが、既にユーザーがパン開始していれば movestart でキャンセルされる）
      stationSelect.addEventListener("change", () => {
        const st = getSelectedStation();
        if (!st) return;
        currentStationIndex = st.index;
        updateSelectedStationLabel();
        panToSelectedStation(true);
      });

      // 検知数変更 → 1 秒入力が止まったらオーバーレイ再描画（パンはしない）
      nInput.addEventListener("input", () => {
        scheduleParamRedraw();
      });

      // 「描画」ボタン → 即座にオーバーレイ描画（駅はパンせず、現在ビューを維持）
      drawButton.addEventListener("click", () => {
        const st = getSelectedStation();
        if (!st) {
          alert("駅を選択してください。");
          return;
        }
        currentStationIndex = st.index;
        updateSelectedStationLabel();
        drawOverlay();
      });
    }

    // --- 駅候補の更新（インクリメンタルサーチ） ---
    function updateStationCandidates(query) {
      const q = (query || "").trim();
      const lower = q.toLowerCase();

      let list = [];

      if (q.length >= 1) {
        // ★ 完全一致（駅名 or かな）を優先
        let exact = stationPositions.find(
          (s) =>
            s.name.toLowerCase() === lower ||
            (s.name_kana || "").toLowerCase() === lower
        );

        if (exact) {
          list = [exact];

          // その他の部分一致を追加（同じ駅は除外）
          const others = stationPositions.filter(
            (s) =>
              (s.searchKey.toLowerCase().includes(lower) ||
                (s.name_kana || "").toLowerCase().includes(lower)) &&
              s.id !== exact.id
          );

          list = list.concat(others.slice(0, 199)); // 最大 200 件
        } else {
          // 通常の部分一致
          list = stationPositions
            .filter(
              (s) =>
                s.searchKey.toLowerCase().includes(lower) ||
                (s.name_kana || "").toLowerCase().includes(lower)
            )
            .slice(0, 200);
        }
      } else {
        // 検索ワードなし → 先頭 100 件
        list = stationPositions.slice(0, 100);
      }

      // 候補更新
      stationSelect.innerHTML = "";
      const fragment = document.createDocumentFragment();

      list.forEach((s) => {
        const opt = document.createElement("option");
        opt.value = s.id;
        opt.textContent = s.name;
        fragment.appendChild(opt);
      });

      stationSelect.appendChild(fragment);

      // 完全一致 / 先頭候補を自動選択
      if (list.length > 0) {
        stationSelect.value = list[0].id;
        currentStationIndex = idToIndex.get(list[0].id);
        updateSelectedStationLabel();
      } else {
        currentStationIndex = null;
        updateSelectedStationLabel();
      }
    }

    // --- 選択中の駅取得＆表示 ---
    function getSelectedStation() {
      const id = Number(stationSelect.value);
      if (!idToIndex.has(id)) return null;
      const idx = idToIndex.get(id);
      return stationPositions[idx];
    }

    function updateSelectedStationLabel() {
      const st = getSelectedStation();
      selectedStationLabel.textContent = st
        ? `選択中の駅: ${st.name}`
        : "選択中の駅: なし";
    }

    // --- 駅位置にマーカー＆任意で地図パン ---
    function panToSelectedStation(centerMap) {
      const st = getSelectedStation();
      if (!st) return;

      const latlng = [st.lat, st.lng];

      if (centerMap) {
        const targetZoom = Math.max(map.getZoom(), 13);
        map.setView(latlng, targetZoom);
      }

      // 駅マーカー（常に最前面の pane に配置）
      if (stationMarker) {
        stationMarker.setLatLng(latlng);
      } else {
        stationMarker = L.circleMarker(latlng, {
          radius: 10,
          color: "#ff0000",
          weight: 3,
          fillColor: "#ff4d4d",
          fillOpacity: 0.9,
          pane: "stationPane",
        }).addTo(map);
      }
    }

    // --- マップ移動後の再描画をデバウンス ---
    function scheduleMapRedraw() {
      if (mapRedrawTimer) clearTimeout(mapRedrawTimer);
      mapRedrawTimer = setTimeout(() => {
        drawOverlay();
      }, 180);
    }

    // --- パラメータ変更後の再描画をデバウンス（1 秒） ---
    function scheduleParamRedraw() {
      if (paramRedrawTimer) clearTimeout(paramRedrawTimer);
      paramRedrawTimer = setTimeout(() => {
        drawOverlay();
      }, 1000);
    }

    // --- 段階描画のキャンセル ---
    function cancelProgressiveDraw() {
      if (progressiveDrawTimer) {
        clearTimeout(progressiveDrawTimer);
        progressiveDrawTimer = null;
      }
      currentDrawingGridSize = null;
      currentDrawingCancelled = true;
    }

    // --- 次のグリッドサイズをスケジュール ---
    function scheduleNextGridSize(currentSize) {
      // グリッドサイズの段階: 16 -> 8 -> 4 -> 2
      const nextSize = currentSize === 16 ? 8 : currentSize === 8 ? 4 : currentSize === 4 ? 2 : null;
      
      if (nextSize === null) {
        // 最終段階（2px）に到達したので終了
        currentDrawingGridSize = null;
        return;
      }

      // 次の段階を500msec後にスケジュール
      progressiveDrawTimer = setTimeout(() => {
        // ユーザー操作中なら中断
        if (isUserInteracting) {
          cancelProgressiveDraw();
          return;
        }
        
        drawOverlayWithGridSize(nextSize);
      }, 500);
    }

    // =========================
    // kd-tree 実装
    // =========================

    function buildKDTree(points, depth = 0) {
      if (!points || points.length === 0) return null;

      const axis = depth % 2; // 0: lng, 1: lat

      const sorted = points.slice().sort((a, b) => {
        if (axis === 0) {
          return a.lng - b.lng;
        } else {
          return a.lat - b.lat;
        }
      });

      const mid = Math.floor(sorted.length / 2);
      const node = {
        point: sorted[mid],
        axis,
        left: buildKDTree(sorted.slice(0, mid), depth + 1),
        right: buildKDTree(sorted.slice(mid + 1), depth + 1),
      };
      return node;
    }

    // best[0] を「最も遠い」要素として保持する簡易 max-heap 的配列
    function insertBest(best, point, dist2, k) {
      if (best.length < k) {
        best.push({ point, dist2 });
        best.sort((a, b) => b.dist2 - a.dist2);
      } else if (dist2 < best[0].dist2) {
        best[0] = { point, dist2 };
        best.sort((a, b) => b.dist2 - a.dist2);
      }
    }

    function kdKNearest(node, targetLat, targetLng, k, best) {
      if (!node) return;

      const p = node.point;
      const dx = targetLng - p.lng;
      const dy = targetLat - p.lat;
      const d2 = dx * dx + dy * dy;

      insertBest(best, p, d2, k);

      const axis = node.axis;
      const diff = axis === 0 ? dx : dy;

      const nearSide = diff <= 0 ? node.left : node.right;
      const farSide = diff <= 0 ? node.right : node.left;

      kdKNearest(nearSide, targetLat, targetLng, k, best);

      const bestDist2 = best.length < k ? Infinity : best[0].dist2;
      if (diff * diff < bestDist2) {
        kdKNearest(farSide, targetLat, targetLng, k, best);
      }
    }

    // =========================
    // グリッド描画
    // =========================

    function drawOverlay() {
      // 段階描画をキャンセルして16pxから開始
      cancelProgressiveDraw();
      currentDrawingCancelled = false;
      drawOverlayWithGridSize(16);
    }

    function drawOverlayWithGridSize(gridPx) {
      const st = getSelectedStation();
      if (!st) return;

      const n = Math.max(1, Number(nInput.value) || 1);
      currentDrawingGridSize = gridPx;
      currentDrawingCancelled = false;

      // 新しいレイヤーを作成（まだマップには追加しない）
      newOverlayLayer = L.layerGroup();

      const targetLat = st.lat;
      const targetLng = st.lng;

      const mapSize = map.getSize();
      const width = mapSize.x;
      const height = mapSize.y;

      let currentY = 0;

      // 行ごとに非同期で描画
      function drawNextRows() {
        if (currentDrawingCancelled) {
          newOverlayLayer = null;
          return;
        }

        const startTime = performance.now();
        const maxTime = 16; // 1フレーム(16ms)内で処理

        while (currentY < height && (performance.now() - startTime) < maxTime) {
          const y = currentY;
          let runType = null;
          let runStartX = 0;

          for (let x = 0; x < width; x += gridPx) {
            const cx = x + gridPx / 2;
            const cy = y + gridPx / 2;
            const latlng = map.containerPointToLatLng([cx, cy]);

            let cellType = null;

            if (latlng.lng < -180 || latlng.lng > 180) {
              cellType = null;
            } else {
              const dyT = latlng.lat - targetLat;
              const dxT = latlng.lng - targetLng;
              const dTarget2 = dxT * dxT + dyT * dyT;

              if (dTarget2 === 0) {
                cellType = "exact";
              } else {
                let closerCount = 0;
                for (let i = 0; i < stationPositions.length; i++) {
                  if (i === st.index) continue;
                  const sp = stationPositions[i];
                  const dy = latlng.lat - sp.lat;
                  const dx = latlng.lng - sp.lng;
                  const d2 = dx * dx + dy * dy;
                  if (d2 < dTarget2) {
                    closerCount++;
                    if (closerCount >= n) break;
                  }
                }
                if (closerCount < n) {
                  cellType = (closerCount + 1 === n) ? "exact" : "inner";
                }
              }
            }

            if (cellType === runType) {
              continue;
            } else {
              if (runType !== null) {
                addGridRunRect(runStartX, y, x, gridPx, runType, newOverlayLayer);
              }
              if (cellType !== null) {
                runType = cellType;
                runStartX = x;
              } else {
                runType = null;
              }
            }
          }

          if (runType !== null) {
            addGridRunRect(runStartX, y, width, gridPx, runType, newOverlayLayer);
          }

          currentY += gridPx;
        }

        if (currentY < height) {
          requestAnimationFrame(drawNextRows);
        } else {
          // 描画完了後、古いレイヤーと入れ替え
          if (!currentDrawingCancelled && newOverlayLayer) {
            overlayLayer.clearLayers();
            overlayLayer.remove();
            overlayLayer = newOverlayLayer;
            overlayLayer.addTo(map);
            newOverlayLayer = null;
          }
          // 次のグリッドサイズをスケジュール
          scheduleNextGridSize(gridPx);
        }
      }

      requestAnimationFrame(drawNextRows);
    }

    // 横方向の区間 [x0, x1) を一気に塗る
    function addGridRunRect(x0, y0, x1, gridPx, type, targetLayer) {
      const nw = map.containerPointToLatLng([x0, y0]);
      const se = map.containerPointToLatLng([x1, y0 + gridPx]);

      const style =
        type === "exact"
          ? {
              pane: "gridPane",
              color: "#ff0000",
              weight: 0,
              fillColor: "#ff6666",
              fillOpacity: 0.35,
            }
          : {
              pane: "gridPane",
              color: "#0000ff",
              weight: 0,
              fillColor: "#6666ff",
              fillOpacity: 0.25,
            };

      const rect = L.rectangle([nw, se], style);
      targetLayer.addLayer(rect);
    }


    function addGridRect(x0, y0, gridPx, type) {
      const x1 = x0 + gridPx;
      const y1 = y0 + gridPx;

      const nw = map.containerPointToLatLng([x0, y0]);
      const se = map.containerPointToLatLng([x1, y1]);

      let style;
      if (type === "exact") {
        // rank === n → 赤
        style = {
          pane: "gridPane",
          color: "#ff0000",
          weight: 0,
          fillColor: "#ff6666",
          fillOpacity: 0.35,
        };
      } else {
        // rank < n → 青
        style = {
          pane: "gridPane",
          color: "#0000ff",
          weight: 0,
          fillColor: "#6666ff",
          fillOpacity: 0.25,
        };
      }

      const rect = L.rectangle([nw, se], style);
      overlayLayer.addLayer(rect);
    }
  </script>
</body>
</html>
