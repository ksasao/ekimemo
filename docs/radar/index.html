<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>駅メモ！レーダー検知範囲</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    :root {
      color-scheme: light;
      --accent: #2f80ff;
      --accent-soft: #e3f0ff;
      --accent-strong: #175ddc;
      --border-soft: #dde2eb;
      --text-main: #222;
      --text-sub: #666;
      --bg: #f5f6f8;
      --control-radius: 10px;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text-main);
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #app {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    /* --- コントロールエリア --- */

    #controls {
      flex: 0 0 auto;
      background: #fff;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
      padding: env(safe-area-inset-top) 6px 4px;
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    #controls-inner {
      max-width: 720px;
      margin: 0 auto;
      padding: 4px 8px;
    }

    #controls-title {
      font-size: 13px;
      font-weight: 600;
      margin: 0 0 4px;
      color: var(--text-sub);
    }

    .form-grid {
      display: grid;
      grid-template-columns: 1fr;
      grid-row-gap: 6px;
    }

    .form-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .form-label {
      flex: 0 0 auto;
      font-size: 12px;
      color: var(--text-sub);
      white-space: nowrap;
    }

    .form-control-wrap {
      flex: 1 1 auto;
      min-width: 0;
    }

    input[type="text"],
    input[type="number"],
    select {
      width: 100%;
      font-size: 14px;
      padding: 6px 10px;
      border-radius: var(--control-radius);
      border: 1px solid var(--border-soft);
      background: #fff;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      transition: border-color 0.15s, box-shadow 0.15s, background-color 0.15s;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(47, 128, 255, 0.18);
    }

    #drawButton {
      width: 110px;
      padding: 8px 0;
      border-radius: 999px;
      border: none;
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-strong) 100%);
      box-shadow: 0 3px 8px rgba(23, 93, 220, 0.4);
      cursor: pointer;
      outline: none;
      transition: transform 0.1s ease, box-shadow 0.1s ease, opacity 0.15s ease;
    }

    #drawButton:active {
      transform: translateY(1px);
      box-shadow: 0 1px 4px rgba(23, 93, 220, 0.35);
    }

    #drawButton:disabled {
      opacity: 0.6;
      box-shadow: none;
      cursor: default;
    }

    #selectedStationLabel {
      margin-top: 4px;
      font-size: 12px;
      color: var(--text-sub);
    }

    /* iOS Safari のフォーム自動ズーム対策 */
    input[type="text"],
    input[type="number"],
    select {
      font-size: 16px;  /* ここが重要。16px 以上にする */
    }

    /* PC では2〜3列レイアウトにしてコンパクトに */
    @media (min-width: 640px) {
      .form-grid {
        grid-template-columns: minmax(0, 2.2fr) minmax(0, 1.4fr) auto auto auto;
        grid-column-gap: 8px;
        align-items: flex-end;
      }

      #drawButton {
        width: 100%;
      }
    }

    /* --- マップ --- */

    #map {
      flex: 1 1 auto;
      min-height: 240px;
      width: 100%;
    }

    .leaflet-control-attribution {
      font-size: 10px;
    }
    .station-label {
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="controls">
      <div id="controls-inner">
        <p id="controls-title">指定した駅がレーダーで取得可能な範囲を描画します</p>

        <div class="form-grid">
          <!-- 駅名検索 -->
          <div class="form-row">
            <div class="form-label">駅名検索</div>
            <div class="form-control-wrap">
              <input
                id="searchInput"
                type="text"
                placeholder="例: 三崎口, 東京, 新大阪..."
                autocomplete="off"
              />
            </div>
          </div>

          <!-- 候補 -->
          <div class="form-row">
            <div class="form-label">候補</div>
            <div class="form-control-wrap">
              <select id="stationSelect"></select>
            </div>
          </div>

          <!-- n -->
          <div class="form-row">
            <div class="form-label">検知数</div>
            <div class="form-control-wrap">
              <select id="nInput"></select>
            </div>
          </div>

          <!-- 描画ボタン -->
          <div class="form-row" style="grid-column: 1 / -1; justify-content: flex-start; margin-top: 4px;">
            <div class="form-control-wrap" style="max-width: 140px;">
              <button id="drawButton">描画</button>
            </div>
          </div>
        </div>

        <div id="selectedStationLabel">選択中の駅: なし</div>
      </div>
    </div>

    <div id="map"></div>
  </div>

  <script>
    // --- データ保持 ---
    let stations = [];
    let stationPositions = [];
    const idToIndex = new Map();
    let lines = [];
    const codeToLine = new Map();

    // 県コードから県名への変換マップ
    const prefectureNames = {
      1: '北海道', 2: '青森県', 3: '岩手県', 4: '宮城県', 5: '秋田県', 6: '山形県', 7: '福島県',
      8: '茨城県', 9: '栃木県', 10: '群馬県', 11: '埼玉県', 12: '千葉県', 13: '東京都', 14: '神奈川県',
      15: '新潟県', 16: '富山県', 17: '石川県', 18: '福井県', 19: '山梨県', 20: '長野県',
      21: '岐阜県', 22: '静岡県', 23: '愛知県', 24: '三重県', 25: '滋賀県', 26: '京都府', 27: '大阪府',
      28: '兵庫県', 29: '奈良県', 30: '和歌山県', 31: '鳥取県', 32: '島根県', 33: '岡山県', 34: '広島県',
      35: '山口県', 36: '徳島県', 37: '香川県', 38: '愛媛県', 39: '高知県', 40: '福岡県',
      41: '佐賀県', 42: '長崎県', 43: '熊本県', 44: '大分県', 45: '宮崎県', 46: '鹿児島県', 47: '沖縄県'
    };

    // kd-tree 用
    let kdRoot = null;

    // Leaflet 関連
    let map;
    let overlayLayer;
    let newOverlayLayer = null; // 描画中の新しいレイヤー
    let stationMarker;
    let stationMarkerLabel; // 選択中の駅の駅名ラベル
    let stationDotsLayer; // 各駅の円と駅名を表示するレイヤー

    // 現在選択中の駅インデックス
    let currentStationIndex = null;

    // 各種デバウンス用タイマー
    let searchPanTimer = null;      // 検索入力 → 駅へパン
    let mapRedrawTimer = null;      // マップ移動終了 → オーバーレイ再描画
    let paramRedrawTimer = null;    // n / グリッド変更 → オーバーレイ再描画

    // グリッド段階描画制御
    let isUserInteracting = false;  // ユーザー操作中フラグ
    let progressiveDrawTimer = null; // 段階描画用タイマー
    let currentDrawingGridSize = null; // 現在描画中のグリッドサイズ
    let currentDrawingCancelled = false; // 現在の描画がキャンセルされたか

    // DOM キャッシュ
    const searchInput = document.getElementById("searchInput");
    const stationSelect = document.getElementById("stationSelect");
    const nInput = document.getElementById("nInput");
    const drawButton = document.getElementById("drawButton");
    const selectedStationLabel = document.getElementById("selectedStationLabel");

    function fillSelectRange(selectEl, start, end, step, defaultValue, labelSuffix = '') {
      for (let v = start; v <= end; v += step) {
        const opt = document.createElement('option');
        opt.value = String(v);
        opt.textContent = labelSuffix ? `${v} ${labelSuffix}` : String(v);
        if (v === defaultValue) {
          opt.selected = true;
        }
        selectEl.appendChild(opt);
      }
    }

    // 検知数: 1〜50, 1刻み
    fillSelectRange(nInput, 1, 50, 1, 18, '駅');

    // --- 初期化 ---
    initMap();
    loadStations();

    function initMap() {
      map = L.map("map", {
        center: [35.681236, 139.767125], // 東京駅あたり
        zoom: 11,
        zoomControl: true,
        preferCanvas: false,
      });

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution:
          '&copy; OpenStreetMap contributors / 駅情報は <a href="https://github.com/Seo-4d696b75/station_database/blob/main/README.md" target="_blank" rel="noopener noreferrer">駅データ</a> を利用しています',
      }).addTo(map);

      // スケール（距離目盛り）を右下に追加
      L.control.scale({
        position: 'bottomright',
        metric: true,
        imperial: false,
        maxWidth: 150
      }).addTo(map);

      // グリッド描画用の pane / layer
      map.createPane("gridPane");
      map.getPane("gridPane").style.zIndex = 400;
      map.getPane("gridPane").style.pointerEvents = "none";

      // 駅ドット用 pane（グリッドより上、選択駅マーカーより下）
      map.createPane("stationDotsPane");
      map.getPane("stationDotsPane").style.zIndex = 600;
      // クリック可能にするため pointerEvents は設定しない
      
      // 駅マーカー用 pane（最前面）
      map.createPane("stationPane");
      map.getPane("stationPane").style.zIndex = 650;

      overlayLayer = L.layerGroup().addTo(map);
      stationDotsLayer = L.layerGroup().addTo(map);

      // マップ操作開始 → ユーザー操作フラグON、段階描画キャンセル、検索パンタイマーもキャンセル
      map.on("movestart zoomstart", () => {
        isUserInteracting = true;
        cancelProgressiveDraw();
        if (searchPanTimer) {
          clearTimeout(searchPanTimer);
          searchPanTimer = null;
        }
      });

      // マップ操作終了 → ユーザー操作フラグOFF、オーバーレイ再描画（パン位置は維持）
      map.on("moveend zoomend", () => {
        isUserInteracting = false;
        if (currentStationIndex == null) return;
        scheduleMapRedraw();
      });
    }

    function selectInitialStationByName(name) {
      // 名前で駅を検索
      const st = stationPositions.find(s => s.name === name);
      if (!st) return;

      // 検索ボックスは空白のまま
      searchInput.value = "";

      // 初期化時は stationSelect を直接設定
      stationSelect.innerHTML = "";
      const opt = document.createElement("option");
      opt.value = st.id;
      opt.textContent = st.name;
      stationSelect.appendChild(opt);

      // 選択インデックスをセット
      stationSelect.value = st.id;
      currentStationIndex = st.index;
      updateSelectedStationLabel();

      // 地図パンとマーカー設置
      panToSelectedStation(true);

      // グリッド描画
      drawOverlay();
      
      // 駅ドット表示
      updateStationDots();
    }


    async function loadStations() {
      try {
        // line.jsonを先に読み込む
        const lineResp = await fetch("line.json");
        const lineData = await lineResp.json();
        
        lines = lineData;
        lines.forEach((line) => {
          codeToLine.set(line.code, line);
        });

        // station.jsonを読み込む
        const resp = await fetch("station.json");
        const data = await resp.json();

        stations = data.map((s, index) => ({
          id: s.id,
          code: s.code,
          name: s.name,
          name_kana: (s.name_kana || "").toString(),
          lat: Number(s.lat),
          lng: Number(s.lng),
          prefecture: s.prefecture,
          lines: s.lines || [],
          index,
        }));

        stationPositions = stations.map((s) => ({
          lat: s.lat,
          lng: s.lng,
          name: s.name,
          searchKey: s.name.replace(/\(.*?\)/g, '').trim(),
          name_kana: s.name_kana,
          prefecture: s.prefecture,
          lines: s.lines,
          id: s.id,
          index: s.index,
        }));

        stations.forEach((s, idx) => {
          idToIndex.set(s.id, idx);
        });

        // kd-tree 構築
        kdRoot = buildKDTree(stationPositions);

        // イベント登録
        setupEventHandlers();
        selectInitialStationByName("品川");
      } catch (e) {
        console.error("データの読み込みに失敗しました", e);
        alert("データの読み込みに失敗しました。ファイルの配置を確認してください。");
      }
    }

    let lastSearchValue = '';
    let incrementalSearchTimerId = null;

    function setupEventHandlers() {
      // インクリメンタルサーチ:
      //  - 候補の更新は即時
      //  - 入力が 1 秒止まったら現在の候補で駅にパン（但しユーザーパン中はキャンセル）
      searchInput.addEventListener("input", () => {
        const q = searchInput.value.trim();
        if (incrementalSearchTimerId !== null) {
          clearTimeout(incrementalSearchTimerId);
          incrementalSearchTimerId = null;
        }

        if (q === '') {
          lastSearchValue = '';
          if (searchPanTimer) {
            clearTimeout(searchPanTimer);
            searchPanTimer = null;
          }
          return;
        }
        // 「削除操作っぽいか？」を判定（長さが短くなっていれば削除とみなす）
        const isDeletion = q.length < lastSearchValue.length;
        lastSearchValue = q;

        if (isDeletion) {
          // バックスペース等のときは少し待ってから検索
          incrementalSearchTimerId = setTimeout(() => {
            updateStationCandidates(q);
            incrementalSearchTimerId = null;
          }, 350); // ここで待ち時間を調整
        } else {
          // 追加入力などは即時に検索
          updateStationCandidates(q);
        }

        if (searchPanTimer) clearTimeout(searchPanTimer);
        searchPanTimer = setTimeout(() => {
          panToSelectedStation(true);
        }, 1000);
      });

      // 候補選択が変わったら即座に駅＆ラベル更新（パンは行うが、既にユーザーがパン開始していれば movestart でキャンセルされる）
      stationSelect.addEventListener("change", () => {
        const st = getSelectedStation();
        if (!st) return;
        currentStationIndex = st.index;
        updateSelectedStationLabel();
        panToSelectedStation(true);
      });

      // 検知数変更 → 1 秒入力が止まったらオーバーレイ再描画（パンはしない）
      nInput.addEventListener("input", () => {
        scheduleParamRedraw();
      });

      // 「描画」ボタン → 即座にオーバーレイ描画（パンを行う）
      drawButton.addEventListener("click", () => {
        const st = getSelectedStation();
        if (!st) {
          alert("駅を選択してください。");
          return;
        }
        currentStationIndex = st.index;
        updateSelectedStationLabel();
        panToSelectedStation(true);
      });
    }

    // --- 駅候補の更新（インクリメンタルサーチ） ---
    function updateStationCandidates(query) {
      const q = (query || "").trim();
      const lower = q.toLowerCase();

      let list = [];

      if (q.length >= 1) {
        // ★ 完全一致（駅名 or かな）を優先
        let exact = stationPositions.find(
          (s) =>
            s.name.toLowerCase() === lower ||
            (s.name_kana || "").toLowerCase() === lower
        );

        if (exact) {
          list = [exact];

          // その他の部分一致を追加（同じ駅は除外）
          const others = stationPositions.filter(
            (s) =>
              (s.searchKey.toLowerCase().includes(lower) ||
                (s.name_kana || "").toLowerCase().includes(lower)) &&
              s.id !== exact.id
          );

          list = list.concat(others.slice(0, 199)); // 最大 200 件
        } else {
          // 通常の部分一致
          list = stationPositions
            .filter(
              (s) =>
                s.searchKey.toLowerCase().includes(lower) ||
                (s.name_kana || "").toLowerCase().includes(lower)
            )
            .slice(0, 200);
        }
      } else {
        // 検索ワードなし → 先頭 100 件
        list = stationPositions.slice(0, 100);
      }

      // 候補更新
      stationSelect.innerHTML = "";
      const fragment = document.createDocumentFragment();

      list.forEach((s) => {
        const opt = document.createElement("option");
        opt.value = s.id;
        opt.textContent = s.name;
        fragment.appendChild(opt);
      });

      stationSelect.appendChild(fragment);

      // 完全一致 / 先頭候補を自動選択
      if (list.length > 0) {
        stationSelect.value = list[0].id;
        currentStationIndex = idToIndex.get(list[0].id);
        updateSelectedStationLabel();
      } else {
        currentStationIndex = null;
        updateSelectedStationLabel();
      }
    }

    // --- 選択中の駅取得＆表示 ---
    function getSelectedStation() {
      const id = Number(stationSelect.value);
      if (!idToIndex.has(id)) return null;
      const idx = idToIndex.get(id);
      return stationPositions[idx];
    }

    function updateSelectedStationLabel() {
      const st = getSelectedStation();
      selectedStationLabel.textContent = st
        ? `選択中の駅: ${st.name}`
        : "選択中の駅: なし";
    }

    // --- 駅位置にマーカー＆任意で地図パン ---
    function panToSelectedStation(centerMap) {
      const st = getSelectedStation();
      if (!st) return;

      const latlng = [st.lat, st.lng];

      if (centerMap) {
        const targetZoom = Math.max(map.getZoom(), 13);
        map.setView(latlng, targetZoom);
      }

      // 駅マーカー（常に最前面の pane に配置）
      if (stationMarker) {
        stationMarker.setLatLng(latlng);
        // ポップアップの内容を更新（既に選択されているため「この駅を指定」リンクは不要）
        const prefectureName = prefectureNames[st.prefecture] || '不明';
        const linesHTML = getLineNamesHTML(st.lines);
        const popupContent = `
          <div style="font-family: system-ui, sans-serif; min-width: 150px;">
            <div style="font-size: 16px; font-weight: 700; margin-bottom: 4px; color: #222;">${st.name}</div>
            <div style="font-size: 13px; color: #666; margin-bottom: 6px;">${st.name_kana}</div>
            <div style="font-size: 13px; color: #444; border-top: 1px solid #ddd; padding-top: 4px;">${prefectureName}</div>
            ${linesHTML}
            <div style="font-size: 12px; color: #888; margin-top: 6px; padding-top: 4px; border-top: 1px solid #eee;">現在選択中の駅</div>
          </div>
        `;
        stationMarker.setPopupContent(popupContent);
      } else {
        stationMarker = L.circleMarker(latlng, {
          radius: 10,
          color: "#ff0000",
          weight: 3,
          fillColor: "#ff4d4d",
          fillOpacity: 0.9,
          pane: "stationPane",
        }).addTo(map);
        
        // ポップアップを追加（駅名、読み方、県名、路線名を表示）
        const prefectureName = prefectureNames[st.prefecture] || '不明';
        const linesHTML = getLineNamesHTML(st.lines);
        const popupContent = `
          <div style="font-family: system-ui, sans-serif; min-width: 150px;">
            <div style="font-size: 16px; font-weight: 700; margin-bottom: 4px; color: #222;">${st.name}</div>
            <div style="font-size: 13px; color: #666; margin-bottom: 6px;">${st.name_kana}</div>
            <div style="font-size: 13px; color: #444; border-top: 1px solid #ddd; padding-top: 4px;">${prefectureName}</div>
            ${linesHTML}
            <div style="font-size: 12px; color: #888; margin-top: 6px; padding-top: 4px; border-top: 1px solid #eee;">現在選択中の駅</div>
          </div>
        `;
        stationMarker.bindPopup(popupContent, {
          closeButton: true,
          offset: [0, -5]
        });
      }
      
      // 赤いドットの下に駅名ラベルを表示（赤い文字、白い縁取り）
      const labelIcon = L.divIcon({
        className: 'station-label',
        html: `<div style="
          position: absolute;
          left: -100px;
          top: 8px;
          width: 200px;
          font-size: 16px;
          font-weight: 700;
          color: #CC2222;
          text-align: center;
          text-shadow: 
            -2px -2px 0 #fff,
            2px -2px 0 #fff,
            -2px 2px 0 #fff,
            2px 2px 0 #fff,
            -2px 0 0 #fff,
            2px 0 0 #fff,
            0 -2px 0 #fff,
            0 2px 0 #fff,
            -1px -1px 0 #fff,
            1px -1px 0 #fff,
            -1px 1px 0 #fff,
            1px 1px 0 #fff;
          white-space: nowrap;
          pointer-events: none;
        ">${st.name}</div>`,
        iconSize: [0, 0],
        iconAnchor: [0, 0]
      });
      
      if (stationMarkerLabel) {
        stationMarkerLabel.setLatLng(latlng);
        stationMarkerLabel.setIcon(labelIcon);
      } else {
        stationMarkerLabel = L.marker(latlng, {
          icon: labelIcon,
          pane: 'stationPane',
          interactive: false
        }).addTo(map);
      }
    }

    // --- マップ移動後の再描画をデバウンス ---
    function scheduleMapRedraw() {
      if (mapRedrawTimer) clearTimeout(mapRedrawTimer);
      mapRedrawTimer = setTimeout(() => {
        drawOverlay();
        updateStationDots();
      }, 180);
    }

    // --- 駅を指定する関数 ---
    function selectStationByName(stationName) {
      // 検索入力に駅名をセット
      searchInput.value = stationName;
      
      // 候補を更新
      updateStationCandidates(stationName);
      
      // 選択状態を更新
      updateSelectedStationLabel();
      
      // 地図をパンしてグリッドを再描画
      panToSelectedStation(true);
      drawOverlay();
      updateStationDots();
    }

    // --- 路線名を取得する関数 ---
    function getLineNamesHTML(lineCodes) {
      if (!lineCodes || lineCodes.length === 0) {
        return '';
      }
      
      const lineNames = lineCodes
        .map(code => {
          const line = codeToLine.get(code);
          return line ? line.name : null;
        })
        .filter(name => name !== null);
      
      if (lineNames.length === 0) {
        return '';
      }
      
      return `
        <div style="font-size: 12px; color: #555; margin-top: 6px; padding-top: 4px; border-top: 1px solid #eee;">
          <div style="font-weight: 600; margin-bottom: 2px;">路線:</div>
          <div style="line-height: 1.4;">${lineNames.join('、')}</div>
        </div>
      `;
    }

    // --- 画面内の駅ドットと駅名を更新 ---
    function updateStationDots() {
      stationDotsLayer.clearLayers();
      
      const bounds = map.getBounds();
      const zoom = map.getZoom();
      // ズームレベル10以下では駅ドットを非表示
      if (zoom <= 10) {
        return;
      }
      
      // ズームレベルに応じて駅名の表示を制御
      // zoom 14以上で駅名表示、それ以下は円のみ
      const showLabels = zoom >= 13;
      
      // 画面内に表示される駅の数をカウント
      let visibleStationCount = 0;
      stationPositions.forEach(s => {
        if (bounds.contains([s.lat, s.lng])) {
          visibleStationCount++;
        }
      });
      
      // 駅が多すぎる場合は駅名を非表示（200駅以上）
      const shouldShowLabels = showLabels && visibleStationCount < 200;
      // 画面内の駅を表示
      stationPositions.forEach((s, idx) => {
        // 選択中の駅は除外（別の赤いマーカーで表示されているため）
        if (idx === currentStationIndex) return;
        
        if (bounds.contains([s.lat, s.lng])) {
          // 緑の円を表示
          const circle = L.circleMarker([s.lat, s.lng], {
            radius: 9,
            color: '#22AA22',
            weight: 3,
            fillColor: '#66EE66',
            fillOpacity: 1,
            pane: 'stationDotsPane',
            interactive: true  // クリック可能にする
          });
          
          // ポップアップを追加（駅名、読み方、県名、路線名、「この駅を指定」リンクを表示）
          const prefectureName = prefectureNames[s.prefecture] || '不明';
          const linesHTML = getLineNamesHTML(s.lines);
          const popupContent = `
            <div style="font-family: system-ui, sans-serif; min-width: 150px;">
              <div style="font-size: 16px; font-weight: 700; margin-bottom: 4px; color: #222;">${s.name}</div>
              <div style="font-size: 13px; color: #666; margin-bottom: 6px;">${s.name_kana}</div>
              <div style="font-size: 13px; color: #444; border-top: 1px solid #ddd; padding-top: 4px; margin-bottom: 4px;">${prefectureName}</div>
              ${linesHTML}
              <div style="margin-top: 8px;">
                <a href="#" onclick="selectStationByName('${s.name.replace(/'/g, "\\'")}'); return false;" style="
                  display: inline-block;
                  padding: 6px 12px;
                  background: linear-gradient(135deg, #2f80ff 0%, #175ddc 100%);
                  color: white;
                  text-decoration: none;
                  border-radius: 6px;
                  font-size: 13px;
                  font-weight: 600;
                  text-align: center;
                  box-shadow: 0 2px 4px rgba(23, 93, 220, 0.3);
                  transition: transform 0.1s ease, box-shadow 0.1s ease;
                " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 3px 6px rgba(23, 93, 220, 0.4)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(23, 93, 220, 0.3)';">この駅を指定</a>
              </div>
            </div>
          `;
          circle.bindPopup(popupContent, {
            closeButton: true,
            offset: [0, -5]
          });

          
          stationDotsLayer.addLayer(circle);
          
          // 駅名を表示（条件を満たす場合のみ）
          if (shouldShowLabels) {
            const label = L.marker([s.lat, s.lng], {
              icon: L.divIcon({
                className: 'station-label',
                html: `<div style="
                  position: absolute;
                  left: -100px;
                  top: 8px;
                  width: 200px;
                  font-size: 16px;
                  font-weight: 700;
                  color: #2255CC;
                  text-align: center;
                  text-shadow: 
                    -2px -2px 0 #fff,
                    2px -2px 0 #fff,
                    -2px 2px 0 #fff,
                    2px 2px 0 #fff,
                    -2px 0 0 #fff,
                    2px 0 0 #fff,
                    0 -2px 0 #fff,
                    0 2px 0 #fff,
                    -1px -1px 0 #fff,
                    1px -1px 0 #fff,
                    -1px 1px 0 #fff,
                    1px 1px 0 #fff;
                  white-space: nowrap;
                  pointer-events: none;
                ">${s.name}</div>`,
                iconSize: [0, 0],
                iconAnchor: [0, 0]
              }),
              pane: 'stationDotsPane',
              interactive: false
            });
            console.log("visible", s.name);
            stationDotsLayer.addLayer(label);
          }
        }
      });
    }

    // --- パラメータ変更後の再描画をデバウンス（1 秒） ---
    function scheduleParamRedraw() {
      if (paramRedrawTimer) clearTimeout(paramRedrawTimer);
      paramRedrawTimer = setTimeout(() => {
        drawOverlay();
      }, 1000);
    }

    // --- 段階描画のキャンセル ---
    function cancelProgressiveDraw() {
      if (progressiveDrawTimer) {
        clearTimeout(progressiveDrawTimer);
        progressiveDrawTimer = null;
      }
      currentDrawingGridSize = null;
      currentDrawingCancelled = true;
      newOverlayLayer = null;
    }

    // --- 次のグリッドサイズをスケジュール ---
    function scheduleNextGridSize(currentSize) {
      // グリッドサイズの段階: 16 -> 8 -> 4 -> 2
      const nextSize = currentSize === 16 ? 8 : currentSize === 8 ? 4 : currentSize === 4 ? 2 : null;
      
      if (nextSize === null) {
        // 最終段階（2px）に到達したので終了
        currentDrawingGridSize = null;
        return;
      }

      // 次の段階を500msec後にスケジュール
      progressiveDrawTimer = setTimeout(() => {
        // ユーザー操作中なら中断
        if (isUserInteracting) {
          cancelProgressiveDraw();
          return;
        }
        
        drawOverlayWithGridSize(nextSize);
      }, 500);
    }

    // =========================
    // kd-tree 実装
    // =========================

    function buildKDTree(points, depth = 0) {
      if (!points || points.length === 0) return null;

      const axis = depth % 2; // 0: lng, 1: lat

      const sorted = points.slice().sort((a, b) => {
        if (axis === 0) {
          return a.lng - b.lng;
        } else {
          return a.lat - b.lat;
        }
      });

      const mid = Math.floor(sorted.length / 2);
      const node = {
        point: sorted[mid],
        axis,
        left: buildKDTree(sorted.slice(0, mid), depth + 1),
        right: buildKDTree(sorted.slice(mid + 1), depth + 1),
      };
      return node;
    }

    // best[0] を「最も遠い」要素として保持する簡易 max-heap 的配列
    function insertBest(best, point, dist2, k) {
      if (best.length < k) {
        best.push({ point, dist2 });
        best.sort((a, b) => b.dist2 - a.dist2);
      } else if (dist2 < best[0].dist2) {
        best[0] = { point, dist2 };
        best.sort((a, b) => b.dist2 - a.dist2);
      }
    }

    function kdKNearest(node, targetLat, targetLng, k, best) {
      if (!node) return;

      const p = node.point;
      const dx = targetLng - p.lng;
      const dy = targetLat - p.lat;
      const d2 = dx * dx + dy * dy;

      insertBest(best, p, d2, k);

      const axis = node.axis;
      const diff = axis === 0 ? dx : dy;

      const nearSide = diff <= 0 ? node.left : node.right;
      const farSide = diff <= 0 ? node.right : node.left;

      kdKNearest(nearSide, targetLat, targetLng, k, best);

      const bestDist2 = best.length < k ? Infinity : best[0].dist2;
      if (diff * diff < bestDist2) {
        kdKNearest(farSide, targetLat, targetLng, k, best);
      }
    }

    // =========================
    // グリッド描画
    // =========================

    function drawOverlay() {
      // 段階描画をキャンセルして16pxから開始
      cancelProgressiveDraw();
      currentDrawingCancelled = false;
      drawOverlayWithGridSize(16);
    }
    
    function drawOverlayWithGridSize(gridPx) {
      const st = getSelectedStation();
      if (!st) return;

      const n = Math.max(1, Number(nInput.value) || 1);
      currentDrawingGridSize = gridPx;
      currentDrawingCancelled = false;

      // 新しいレイヤーを作成（まだマップには追加しない）
      newOverlayLayer = L.layerGroup();

      const targetLat = st.lat;
      const targetLng = st.lng;

      const mapSize = map.getSize();
      const width = mapSize.x;
      const height = mapSize.y;

      let currentY = 0;

      // 行ごとに非同期で描画
      function drawNextRows() {
        if (currentDrawingCancelled || !newOverlayLayer) {
          return;
        }

        const startTime = performance.now();
        const maxTime = 16; // 1フレーム(16ms)内で処理

        while (currentY < height && (performance.now() - startTime) < maxTime) {
          const y = currentY;
          let runType = null;
          let runStartX = 0;

          for (let x = 0; x < width; x += gridPx) {
            const cx = x + gridPx / 2;
            const cy = y + gridPx / 2;
            const latlng = map.containerPointToLatLng([cx, cy]);

            let cellType = null;

            if (latlng.lng < -180 || latlng.lng > 180) {
              cellType = null;
            } else {
              const dyT = latlng.lat - targetLat;
              const dxT = latlng.lng - targetLng;
              const dTarget2 = dxT * dxT + dyT * dyT;

              if (dTarget2 === 0) {
                cellType = "exact";
              } else {
                let closerCount = 0;
                for (let i = 0; i < stationPositions.length; i++) {
                  if (i === st.index) continue;
                  const sp = stationPositions[i];
                  const dy = latlng.lat - sp.lat;
                  const dx = latlng.lng - sp.lng;
                  const d2 = dx * dx + dy * dy;
                  if (d2 < dTarget2) {
                    closerCount++;
                    if (closerCount >= n) break;
                  }
                }
                if (closerCount < n) {
                  cellType = (closerCount + 1 === n) ? "exact" : "inner";
                }
              }
            }

            if (cellType === runType) {
              continue;
            } else {
              if (runType !== null) {
                addGridRunRect(runStartX, y, x, gridPx, runType, newOverlayLayer);
              }
              if (cellType !== null) {
                runType = cellType;
                runStartX = x;
              } else {
                runType = null;
              }
            }
          }

          if (runType !== null) {
            addGridRunRect(runStartX, y, width, gridPx, runType, newOverlayLayer);
          }

          currentY += gridPx;
        }

        if (currentY < height) {
          requestAnimationFrame(drawNextRows);
        } else {
          // 描画完了後、古いレイヤーと入れ替え
          if (!currentDrawingCancelled && newOverlayLayer) {
            overlayLayer.clearLayers();
            overlayLayer.remove();
            overlayLayer = newOverlayLayer;
            overlayLayer.addTo(map);
            newOverlayLayer = null;
          }
          // 次のグリッドサイズをスケジュール
          scheduleNextGridSize(gridPx);
        }
      }

      requestAnimationFrame(drawNextRows);
    }

    // 横方向の区間 [x0, x1) を一気に塗る
    function addGridRunRect(x0, y0, x1, gridPx, type, targetLayer) {
      if (!targetLayer) return;
      const nw = map.containerPointToLatLng([x0, y0]);
      const se = map.containerPointToLatLng([x1, y0 + gridPx]);

      const style =
        type === "exact"
          ? {
              pane: "gridPane",
              color: "#ff0000",
              weight: 0,
              fillColor: "#ff6666",
              fillOpacity: 0.35,
              interactive: false,
            }
          : {
              pane: "gridPane",
              color: "#0000ff",
              weight: 0,
              fillColor: "#6666ff",
              fillOpacity: 0.25,
              interactive: false,
            };

      const rect = L.rectangle([nw, se], style);
      targetLayer.addLayer(rect);
    }


    function addGridRect(x0, y0, gridPx, type) {
      const x1 = x0 + gridPx;
      const y1 = y0 + gridPx;

      const nw = map.containerPointToLatLng([x0, y0]);
      const se = map.containerPointToLatLng([x1, y1]);

      let style;
      if (type === "exact") {
        // rank === n → 赤
        style = {
          pane: "gridPane",
          color: "#ff0000",
          weight: 0,
          fillColor: "#ff6666",
          fillOpacity: 0.35,
          interactive: false,
        };
      } else {
        // rank < n → 青
        style = {
          pane: "gridPane",
          color: "#0000ff",
          weight: 0,
          fillColor: "#6666ff",
          fillOpacity: 0.25,
          interactive: false,
        };
      }

      const rect = L.rectangle([nw, se], style);
      overlayLayer.addLayer(rect);
    }
  </script>
</body>
</html>
